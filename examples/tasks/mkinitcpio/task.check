~regexp: ^^ \s* "MODULES=(" (.*) ")" \s* $$
generator: <<CODE
!raku
sub check-and-modify() {
   if !matched() {
      # fail check if no MODULES= section found 
      say "assert 0 MODULES= section found";
      return;
   } else {
      my $path = config()<path>;
      say "note: ", capture()[0].raku;
      my @mods = capture()[0].split(/\s+/);
      my $sanity-check = True;
      for qw<filesystems kms>.sort -> $f {
         if $f (elem) @mods {
              say "assert: 1 $f exists in MODULES";
         } else {
              say "assert: 0 $f exists in MODULES";
              $sanity-check = False;
         }
      }
      if "udev" (elem) @mods || "systemd" (elem) @mods {
         say "assert: 1 udev or systemd exists in MODULES";
      } else {
         say "assert: 0 udev or systemd exists in MODULES";
      }
      return unless $sanity-check;

      say "note: start appying patches";
      if config()<zfs_filesystem> or "zfs" (elem) @mods {
         say "note: insert zfs before filesystems";
         for 0 .. @mods.elems -> $i { 
            next if ! @mods[$i].defined; 
            @mods.splice($i,1) if @mods[$i] eq "zfs";
            @mods[$i] = "zfs filesystems" if @mods[$i] eq "filesystems";
         }

      }
      @mods.push("zfs") unless "zfs" (elem) @mods;
      # probably other mods manipulations
      # and then update configuration
      say "note: patch $path";
      replace(
         $path,
         captures-full()[0]<index>,
         "MODULES=({@mods.join(" ")})",
      );
   }
}
check-and-modify();
CODE
