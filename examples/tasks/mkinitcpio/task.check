~regexp: ^^ \s* "MODULES=(" (.*) ")" \s* $$
generator: <<CODE
!raku
sub check-and-modify() {
   if !matched() {
      # fail check if no MODULES= section found 
      say "assert 0 MODULES= section found";
      return;
   } else {
      my $path = config()<path>;
      say "note: MODULES found: ", capture()[0].raku;
      my @mods = capture()[0].split(/\s+/);
      my $indx = 0;
      my %mods; for @mods -> $i { %mods{$i} = $indx; $indx++ };
      my $sanity-check = True;
      for qw<filesystems kms>.sort -> $f {
         if $f (elem) @mods {
              say "assert: 1 $f exists in MODULES";
         } else {
              say "assert: 0 $f exists in MODULES";
              $sanity-check = False;
         }
      }
      if "udev" (elem) @mods || "systemd" (elem) @mods {
         say "assert: 1 udev or systemd exists in MODULES";
      } else {
         say "assert: 0 udev or systemd exists in MODULES";
      }
      return unless $sanity-check;

      say "note: start appying patches";
      if config()<zfs_filesystem> or "zfs" (elem) @mods {
         if config()<zfs_filesystem> and %mods<zfs>:exists {
            say "note: insert zfs before filesystems";
            @mods.splice(%mods<zfs>,1); # remove zfs mod
            @mods[%mods<filesystems>] = "zfs filesystems";
         } elsif config()<zfs_filesystem> and ! %mods<zfs>:exists {
            say "note: add zfs mode";
            @mods.push("zfs"); # add zfs node
         }
      }
      # probably other mods manipulations
      # and then update configuration
      say "note: patch $path";
      replace(
         $path,
         captures-full()[0]<index>,
         "MODULES=({@mods.join(" ")})",
      );
   }
}
check-and-modify();
CODE
